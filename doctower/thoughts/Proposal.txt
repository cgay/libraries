(UTF8)             ========================================
                   Thoughts on a Dylan Documentation System
                   ========================================
                            mailto://d_j_v@mac.com


Dylan libraries are particularly susceptible to under-documentation. It can be
difficult to find the source code that defines a given name, as that name can
be defined far away from its owner module. Additionally, I find library and
module definers to be awkward places for documentation comments because of the
number of names found in them and their fragmentary nature. Module definers,
for example, do not mention additional methods they define on an imported
generic function.

So even if we did not intend to provide an on-line Dylan package system along
the lines of CPAN, we would still really need some sort of documentation
automation. For a Dylan CPAN, some sort of standard is a necessity.

I intend to solve this area for interface documentation. I’d already started
the effort in coming up with a documentation kit for Gwydion Dylan.


==========================================
1 Delivery, Storage, and Cross-Referencing
==========================================

Documentation may be delivered in HTML form or source form (meaning the form
that would be turned into HTML). Source form is the more common solution, and
probably the better of the two.


1.1 HTML Format
===============

Documentation could be available in HTML format, delivered and kept with the
library. This documentation should not be moved to a centralized location as
man pages (for example) are, because

  a) if the library is copied to another computer, the documentation may not
     also be copied; and

  b) that would imply centralized management through a dedicated IDE or
     viewer, which would need to be coded and maintained, and heavily
     customized for Unix or Windows environments. If the viewer is a CGI web-
     server, the problem is worse, because they are a pain to set up for a
     non-web-savvy user.

However, though centralized management should not be required, I don't see a
reason to exclude it, either. A centralized management system could maintain a
documentation catalog linking to specific doc directories. It may be worth
defining an XML file that can contain metadata supporting this scenario.


1.2 Source Form
===============

If the documentation is shipped in its source form and processed by the
recipient into viewable documents, centralized management would be possible
via the processing tool. The tool could integrate all packages into a single
set of HTML files, documenting what is available on that computer—though this
may require subset-detection to keep the process efficient as more packages
are added.

The difficulty is when a library is shipped as a binary and the documentation
is generated by scanning source code. We'd need an intermediate form that
includes everything that would be gathered from reading the source code
directly.

Perhaps this intermediate form could be kept as part of the binary file itself
(including conceptual documentation as well as API reference info).


1.3 Survey Says…
================

  Language  Local documentation distribution method
  --------  -----------------------------------------------------------------
  Java      Usually a separate HTML download, but can be generated statically
            or at tool run-time from Javadoc comments.
  Perl      Generated statically from POD files and comments.
  Python    Generated statically or dynamically from docstrings.
  Ruby      Generated statically from RDoc markup.
  Lisp      No standard method, but CLOS allows docstrings.
  Scheme    No standard method, but available tools work like Javadoc.

All these languages build viewable documentation from its source form, but
require source code to do so. As these languages tend to be scripting or
interpreted languages, the source code is easy to come by. However, Dylan is
compiled, so we cannot rely on having a library’s source code available to the
recipient.


=============================
2 Content and Dylan Semantics
=============================

Documentation consists of conceptual discussion, internal documentation, and
reference information. The latter relates to

  - Classes
  - Generic functions
  - Methods on generic functions
  - Global variables
  - Constants
  - Macros
  - Libraries
  - Modules
  - Recovery protocols

The major difficulties with reference information include

  - Treatment of constant aliases
  - Macro syntax descriptions
  - Additional methods on another library’s generic functions
  - Names that are not exported
  - Complex types
  - Type inferences

Internal documentation is a different kettle of fish, and results in different
decisions in the following discussions.


2.1 Generic Functions and Methods
=================================

Let us suppose that a library defines additional “as” methods that the author
wishes to document.

If the documentation is compiled into an integrated HTML collection by the
recipient, then the new “as” methods can simply be included as entries within
the Dylan library’s “as” general function.

In contrast, stand-alone HTML would have to have separate “as” method entries
(either under a Dylan library entry separate from the Dylan library
documentation proper, or a section dedicated to extensions of other
libraries).


2.2 Aliases
===========

“define constant” can be used to a new duplicate binding for an already-bound
object. In this case, should the name be listed as if it were, e.g., a
function if the existing binding was a function, or should it be listed as a
constant, referring to the existing binding?

Given that it is possible that the alias is exported while its referent is
not, it makes sense that the constant be documented as if it were the same
type as its referent. In other words, the difference should be hidden.


2.3 Macro Syntax
================

Hopefully, a BNF-style syntax specification can be extracted from macro
complexes.


2.4 Missing Names and Complex Types
===================================

What to do with a return value that is of a non-exported type?

These should be treated as the nearest exported type, because as far as the
user is concerned, he can only manipulate the value as if it were that type.
But there may be several nearest exported types; the value may, for example,
be an internal class that derives from both “<range>” and “<character>.” We
must come up with a notation for this case. Perhaps “<object>(<range>,
<character>)?”

Specialized notations must also be used for “type-union,” “one-of,” and
“limited” types.

An additional question is raised when one considers specialized methods that
are only intended for internal use. In this case, the arguments to the method
are not exported. We could say that if the arguments *in* are not exported,
then the method is internal, but if the arguments *out* are not exported, the
method is not internal and can be included in the documentation.

But if an unexported type is returned from a method, it may be an opaque type
intended for another, documented method.

Perhaps it would be better to not document any methods on non-exported types,
subject to manual override.


2.5 Type Inferencing
====================

Slot accessors are added to a general function on “<object>,” but in practice,
the general function is tightly specified to the handful of types that define
an accessor of that name. Should accessors and similar “<object>”-specialized
methods be documented as such, or should they be documented with the most
general (or perhaps most specific) inferences short of “<object>” that can be
determined?

This also applies to return values. Functions that don’t specify a return
value return “#rest <object>,” but in reality, they return something more
specific.


============================================================
3 Documentation Source, Toolchains, and Automatic Extraction
============================================================

3.1 Philosophy of Toolchains
============================

There are two main styles of documentation.

  - Reference-style documentation is the type generally created by automatable
    systems. This type is heavy on the hyperlinks, light on conceptual and
    overview information. It is easier for developers, as they don’t have to
    have document-organizing skills and can write snippets of documentation.
    It is organized around lists of modules, classes, etc.

  - Literate-style documentation is heavy on the prose. Most existing Dylan
    documentation falls into this style. It need not be organized by library
    and module like reference-style documentation typically would be. There is
    less repetition, but more editing and manual organization.

DITA, a professional documentation toolchain, can theoretically combine the
snippets of reference-style documentation with the overarching hierarchy and
prose support of literate-style documentation.

Technically, the primary disadvantage of such a toolchain is the need for
supplemental tools such as XSLT processors. An additional issue would be
impedance mismatches between different stages in the production pipeline;
DITA’s stages would only take place after initial processing of Dylan files.

But for a developer, the primary disadvantage is in the requirements that such
a tool chain lays on him as an author. Every toolchain will impose some
requirements; but these should be kept small, especially for
library-pack-sized documentation like a database interop layer or something.


3.2 Source Code Comments vs. Separate Files
===========================================

Most documentation systems take an approach where some documentation is done
in dedicated files, and some is done in the source code itself, in
documentation comments associated with specific API elements.

          Derived from source comments       Created in dedicated files
          -------------------------------    -------------------------------
  Pros    Proximate to the source code,      Easy to structure for usability.
          therefore it is easy to spot       
          errors and convenient to update    Easy to integrate diagrams into
          documentation as code changes.     a discussion.
                                             
          Elements and organization          Redundant information is easily
          gathered directly from source      extracted and put in one place.
          code are guaranteed correct                
          and maintained automatically.      Easy to refer to overviews; in
                                             many cases, the overview is
          Cannot assume documentation is     implicit in the doc structure.
          read in any particular order,      
          therefore more redundancy.

  Cons    Thwarts overall documentation;     Information must be manually
          related functions or classes       copied from actual source code.
          that could benefit from being      Highly error-prone.
          discussed as a group won’t be.
                                             More work.
          Duplicate passages need to be
          updated wherever they occur.       Need to consider context when
                                             looking up a specific binding.
          
                                             Additional document sections
                                             cannot be easily integrated
                                             automatically.         

How to combine the two approaches to keep the advantages of each without the
disadvantages?

Methods on a generic function can be documented with the generic function
itself. The generic function likely contains general information about the
function, theoretically reducing the need for redundant information in the
method’s documentation. Thus, method documentation can be simplified as shown
in the DRM.

Bindings can be explicitly marked as being part of a certain discussion. This
discussion can be put forth in a dedicated file. The final documentation can
combine them into a single section in a well-understood fashion. These
markings can also define a structure for the documentation, placing items into
a hierarchy. The Open Dylan C-FFI documentation provide an example of how this
might look.

Alternatively, the documentation could consist of distinct reference and
discussion aspects, with a binding’s reference documentation linking to the
appropriate discussion section. This is likely to result in more duplication
of information, however, as the discussion sections will need to delve into
details that are also explained in the reference documentation.

The problem with integrating new sections into existing documentation is only
a problem if we choose to do so. We could have each doc package remain
separate. But we do attempt full integration, the hierarchy marks described
above likely won’t mesh into the existing structure. We could allow a more
limited integration, where “See [subclasses/members] in…” annotations are
automatically added to main binding reference entries.


3.3 Extraction From Library
===========================

The ability to take a library compiled without documentation and auto-generate
some documentation from it is arguably of little or no value. Its greatest
utility would be in dealing with core libraries written as part of the Open
Dylan or Gwydion Dylan projects, where it would be a tremendous task to go
through the source code and bring it into compliance with the documentation
standard.


====================================================
4 Sample Markup Formats and Documentation Generators
====================================================

D Programming Language
  http://www.digitalmars.com/d/ddoc.html
  The “ditto” construct could be handy.

NaturalDocs
  http://www.naturaldocs.org

Perl’s POD Format
  http://en.wikipedia.org/wiki/Plain_Old_Documentation

Ruby’s RDOC Format
  http://www.ruby-doc.org/stdlib/libdoc/rdoc/rdoc/index.html

ASCIIDoc Format
  http://www.methods.co.nz/asciidoc/userguide.html

Wiki Formats
  http://en.wikipedia.org/wiki/Comparison_of_lightweight_markup_languages

Deficiencies of MSDN
  http://thinkwrap.wordpress.com/2007/06/14/msdn-documentation-the-worse-in-class/

reStructured Text
  http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html
  The way headings are done is pretty nice.

Of these, I like the NaturalDocs markup format best. However, none of these
tools can be easily adapted for Dylan use off-the-shelf. At the least, we are
talking major source code changes, and more likely a completely custom tool.
